## ⭐ Cookie

서버에서 클라이언트에 데이터를 저장하는 방법의 하나

쿠키를 이용하는 것은 **서버에서 클라이언트에 쿠키를 전송하는 것** 뿐만 아니라 **클라이언트에서 서버로 쿠키를 전송하는 것**도 포함된다.

서버는 데이터를 저장한 이후 아무 때나 데이터를 가져올 수 없으며 **특정 조건**을 만족하는 경우에만 다시 가져올 수 잇다. ⇒ 이 조건을 **쿠키 옵션**이라고 한다.

- **쿠키 옵션**
  **1. Domain**
  `www.google.com`과 같은 서버에 접속할 수 있는 이름
  - 쿠키 옵션에서 도메인은 포트 및 서브 도메인 정보, 세부 경로를 포함하지 않는다.
  - 서브 도메인 ⇒ www와 같이 도메인 앞의 추가로 작성되는 부분
  - 따라서 `http://www.localhost.com:3000/users/login`라는 url로 요청하면 여기서 도메인은 [`localhost.com`](http://localhost.com/)이다
  - 쿠키 옵션에서 도메인 정보가 존재한다면, 클라이언트에서는 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키를 전송할 수 있다.
  **2. Path**
  서버가 라우팅할 때 사용하는 경로
  - 요청하는 url이 `[http://www.localhost.com:3000/users/login`일](http://www.localhost.com:3000/users/login일) 때, Path 세부 경로는 `/user/login`이다.
  - 명시하지 않으면 기본 `/`으로 설정되어 있다.
  - Path 옵션은 path를 전부 만족하는 경우, 요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송할 수 있다.
  **3. MaxAge or Expires**
  쿠키가 유효한 기간을 정하는 옵션
  - **MaxAge** : 앞으로 몇 초 동안 쿠키가 유효한지 설정
  - **Expires**: 언제까지 유효한지 Date를 지정하는 옵션
  이 유효기간을 지나면 쿠키는 자동으로 파기된다.
  **4.Secure**
  쿠키 전송 시 **사용하는 프로토콜**에 따른 **쿠키 전송 여부**를 결정.
  해당 옵션이 `true`인 경우, 'HTTPS' 프로토콜을 사용하는 경우에만 쿠키를 전송할 수 있다.
  **5. HTTPOnly**
  **자바스크립트에서 브라우저의 쿠키에 접근 여부**를 결정
  해당 옵션이 `true`인 경우 자바스크립트에서 쿠키에 접근할 수 없다.
  default ⇒ `false` , 이 경우 'XSS' 공격에 취약하다.
  **6.** ⭐ **SameSite**
  Cross-Origin 요청을 받은 경우 요청에서 사용한 메소드와 해당 옵션의 조합으로 서버의 쿠키 전송 여부를 결정한다.
  - **Lax** : Cross-Origin 요청이면 'GET' 메소드에 대해서만 쿠키를 전송
    - 사이트가 서로 달라도, GET 요청이면 쿠키 전송이 가능 (3rd-party- cookie, 1st-party-cookie)
  - **Strict:** Cross-Origin이 아닌 'same-site'인 경우에만 쿠키를 전송
    - 사이트가 서로 다르면 쿠키 전송을 할 수 없다.
  - **None**: 항상 쿠키를 보낼 수 있음, 다만 쿠키 옵션 중 `Secure`옵션이 필요함 (항상 **secure가 true**여야 한다. https 프로토콜에서만 사용)
    - 사이트가 달라도 모든 요청에 대해 쿠키 전송이 가능
  이 때 same-site는 요청을 보낸 origin과 서버의 도메인이 같은 경우를 말한다.
  이런 옵션을 지정한 후 **서버에서 클라**로 쿠키를 전송하면 헤더에 `Set-Cookie`라는 프로퍼티에 쿠키를 담아 쿠키를 전송한다.
  이후 **클라 혹은 서버**에서 쿠키를 전송하면 클라는 헤더에 `Cookie`라는 프로퍼티에 쿠키를 담아 서버에 쿠키를 전송한다.

### 쿠키를 이용한 상태 유지

**Stateless한 인터넷 연결을 Stateful 하게 유지할 수 있다**.

다만 쿠키는 오랜 시간 유지될 수 있고, 자바스크립트를 이용해서 쿠키에 접근할 수 있으므로, 쿠키에 민감한 정보를 담지는 말자!

- [ ] 쿠키를 이용해서 할 수 있는 것?
- 로그인 상태 유지하기
- 장바구니

---

## ⭐ 세션기반 인증 Session-based Authentication

## Session

- 서버가 Client에 유일하고 암호화된 ID를 부여한다.
- 중요 데이터는 서버에서 관리한다.
- 보통 하나의 서버에서만 접속 상태를 저장하며, 여러 개의 서버에서 같은 세션 데이터에 접근하려고 하면 session clustering 혹은 공통 session store을 사용해야하는 번거로움이 있다.

### 로그인

**로그인을 통해 인증 정보가 저장되고, 인증된 사용자가 어떤 방식으로 웹사이트를 이용할까?**

사용자가 정확한 아이디와 비밀번호를 입력함 ⇒ 서버는 인증에 성공했다고 판단 ⇒ 그 다음 인증을 필요로 하는 작업(그림에서와 같이 장바구니에 물품을 추가)를 요청하는 경우 ⇒ 또 로그인을 해야할까?

⇒ "인증에 성공함"을 서버가 알고 있다 ⇒ 매번 로그인 할 필요가 없다.

- 서버는 사용자가 인증에 성공했음을 알고 있어야 한다.
- 클라이언트는 인증 성공을 증명할 수단을 갖고 있어야 한다.

**Session**: 사용자가 인증에 성공한 상태

- 서버는 일종의 저장소에 세션을 저장한다. (in-memory, session store - redis와 같은 트랜잭션이 빠른 DB)
- 세션이 만들어지면 각 세션을 구분하는 세션 아이디를 만든다. 클라이언트에서 세션 성공을 증명할 수단으로 세션 아이디를 전달한다.

이때 웹 사이트에서 **로그인을 유지하기 위한 수단**으로 **쿠키**를 사용한다. **쿠키는 서버에서 발급한 세션 아이디를 저장**한다.

[ 쿠키(세션 아이디 저장) ⇒ 서버 ⇒ 세션 스토어에 해당 세션이 존재! ⇒ 서버: 해당 요청에 접근 가능!]

or ⇒ [ 세션 아이디 정보가 없는 경우 ⇒ 요청이 인증되지 않음! ]

### 로그아웃

세션 아이디가 담긴 쿠키는 클라이언트에 저장되어 있고, 서버는 세션을 저장하고 있다. 서버는 세션 아이디로만 요청을 판단한다.

따라서 로그아웃을 하려면

- **서버의 세션 정보를 삭제**
- **클라이언트의 쿠키를 갱신**

해야 한다.

서버가 클라이언트의 쿠키를 임의로 삭제할 수는 없다. 대신 `set-cookie`로 세션 아이디 키값을 무효한 값으로 갱신해야 한다.

### express-session

- 세션을 관리해주는 모듈
- 세션을 위한 미들웨어로, Express에서 세션을 다룰 수 있는 공간을 쉽게 만들어준다.

[express-session](https://github.com/expressjs/session#reqsession)
