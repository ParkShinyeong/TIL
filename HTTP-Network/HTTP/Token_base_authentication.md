## 토큰 기반 인증 (Token-based Authentication)

**세션 기반 인증**: 서버 혹은 DB에 유저 정보를 담는 인증 방식.

매 요청마다 데이터 베이스를 살펴야 하는 것이 불편, 서버에 부담을 덜고 싶다 ⇒ 토큰 기반 인증

##

### 클라이언트에 인증 정보를 보관하는 방법 ⇒ 토큰 기반 인증

그런데 민감한 정보는 클라이언트에 담으면 안된다고 했는데, 인증에 사용되는 것을 클라이언트에 담아도 될까?

⇒ 토큰은 **유저 정보를 암호화한 상태**로 담을 수 있고, 암호화했기 때문에 클라이언트에 담을 수 있다.

##

### JWT (JSON Web Token)

토큰 기반 인증 중 대표적인 방법!

[(공식 문서)](https://jwt.io/)

**JWT의 종류**

- **Access Token**
  - 보호된 정보들(유저의 이메일, 연락처, 사진 등) 에 접근할 수 있는 권한 부여에 사용
  - 클라이언트가 처음 인증 받을 때 access, refresh 둘 다 받지만, **실제 권한을 얻는데 사용한 토큰은 access 토큰**이다.
  - 악의적인 유저가 access token을 얻어낸다면 자신이 유저인 것 마냥 서버에 여러 요청을 보낼 수 있다. 따라서 access token에 짧은 유효기간을 주어 오랫동안 사용할 수 없도록 한다.
- **Refresh Token**
  - access token의 유효기간이 만료되면, refresh 토큰을 사용하여 새로운 access token을 발급받는다.
  - 이 때 유저는 다시 로그인 할 필요가 없다.
  - refresh key도 악의적인 유저에게 탈취당한다면 큰 문제가 될 수 있으므로, 상당히 오랜기간 동안 계속 토큰을 발급받으면서 유저에게 피해를 줄 수 있다.
    - 유저의 편의가 더 중요하다! ⇒ refresh 토큰을 사용
    - 정보를 지키는 것이 더 중요하다 ⇒ refresh 토큰 사용 X

##

**JWT의 구조**

Header-Payload-Signature

a*aaaaa.bbbbbb.cccc*ccc ⇒ 이렇게 .으로 나누어진 3부분이 존재

##

**1. Header**

**어떤 종류의 토큰**인지 (지금은 JWT), **어떤 알고리즘으로 암호화**할지 (sign) 적혀있다.

```jsx
{
  "alg": "HS256",
  "typ": "JWT"
}
```

이 json 객체를 base64 방식으로 인코딩하면 JWT의 첫부분이 완성된다.

###

**2. Payload**

어떤 정보에 접근 가능한지 **권한**이나, 사용자의 유저 이름 등 **필요한 데이터**를 이곳에 담아 암호화시킨다.

암호화될 거지만, 되도록 민감한 정보는 담지 않는다.

```jsx
{
  "sub": "someInformation",
  "name": "phillip",
  "iat": 151623391
}
```

이 json 객체를 base64 방식으로 인코딩하면 JWT의 두 번째 부분이 완성된다.

###

**3. Signature**

**base64로 인코딩** 된 header, payload 부분이 완성되었다면, 원하는 **비밀 키 (암호화에 추가할 salt)** 를 사용하여 암호화한다.

```jsx
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret);
```

HMAC SHA256 알고리즘을 사용해 암호화한다면, 아래와 같은 방식으로 생성한다.

#

### JWT 사용 예시

jwt는 권한 부여에 굉장히 유용하다.

ex) 새로 다운 받은 앱이 Gmail과 연동되어 이메일을 읽어와야 할 때

유저는

1. Gmail 인증 서버에 로그인 정보를 제공한다.
2. 성공적으로 인증 시 jwt를 발급받는다.
3. 앱은 jwt를 사용해 해당 유저의 gmail을 읽거나 사용할 수 있다.

#

### 토큰 기반 인증 절차

1. 클라이언트에서 서버에 아이디와 비밀번호를 담아 **로그인(Post) 요청**을 보낸다.
2. 서버에서 아이디와 비번을 확인한다 ⇒ 일치한다면, 암호화된 **JWT 토큰**을 생성 ⇒ 클라이언트에 전달
3. 클라이언트는 토큰을 localstorage/ cookie / react의 state 등에 저장한다.
   1. 토큰은 access Token, refresh Token 두가지
   2. 토큰에 담길 정보는 (payload) 유저의 식별 정보, 권한이 부여된 카테고리 등이 될 수 있다
   3. 꼭 두 개의 토큰이 같은 정보를 담을 필요는 없다.
4. 클라이언트에서 서버에 필요한 정보를 요청한다. 이때 **header에 토큰을 같이 넣어서 요청**
   1. Header: **{ Authorization: "Bearer JWT_TOKEN"}**
   2. **Bearer authentication**을 사용한다. [링크1(요약)](https://learning.postman.com/docs/sending-requests/authorization/#bearer-token), [링크2(상세)](https://tools.ietf.org/html/rfc6750)
5. 서버는 JWT 토큰을 해독 ⇒ 우리가 발급한 토큰이 맞군! ⇒ 클라에 원하는 요청 해결/응답을 보낸다.

#

### 토큰 기반 인증의 장점

**1. Statelessness & Scalability(무상태성 & 확장성)**

- 서버는 클라에 대한 정보를 저장할 필요가 없다. (토큰 해독만 판단한다.)
- 클라이언트는 새로운 요청을 보낼 때 토큰을 헤더에 포함시킨다.
  - 서버를 여러 개 가지고 있으면, 같은 토큰으로 여러 서버에서 인증 가능하므로 유용하다.

**2. 안전하다**

- 암호화한 토큰을 사용하고, 암호화 키를 노출할 필요가 없으므로 안전하다

**3. 어디서나 생성 가능**

- 토큰을 확인하는 서버가 토큰을 만들지 않아도 된다.
- 토큰 생성용 서버를 만들거나, 다른 회사에서 토큰 관련 작업을 맡기는 등 다양하게 활용할 수 있다.

**4. 권한 부여에 용이하다**

- 토큰의 payload(내용물) 안에 어떤 정보에 접근 가능한지 정할 수 있다.
  - ex) 서비스의 사진과 연락처 사용 권한만 부여

⭐ 토큰 기반 인증과 세션 기반 인증의 차이점 잘 알아두자!
