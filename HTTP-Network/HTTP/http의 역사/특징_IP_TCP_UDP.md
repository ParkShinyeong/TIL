- **Achievement Goals**
  - HTTP 기반 네트워크 흐름에 대해 이해할 수 있다.
  - TCP/IP 기반 네트워크 흐름에 대해 이해할 수 있다.
    - TCP/IP 패킷이 왜 필요한 지 설명할 수 있다.
    - TCP와 UDP의 차이에 대해 설명할 수 있다.
  - HTTP 기본 동작과 특징에 대해 이해할 수 있다.
    - 상태유지(Stateful)과 무상태(Stateless)의 개념에 대해 설명할 수 있다.
    - HTTP 메시지 구성에 대해 설명할 수 있다.
  - HTTP 헤더의 역할에 대해 이해할 수 있다.
    - 표현, 콘텐츠 협상 등 다양한 헤더의 역할에 대해 알 수 있다.
  - 캐시가 왜 필요한 지 알 수 있다.
    - 브라우저 캐시, 프록시 캐시에 대해 설명할 수 있다.
    - 조건부 요청, 캐시 무효화 방법 등을 사용할 수 있다.

#

# 인터넷 프로토콜 (IP)

클라이언트와 서버는 어떻게 통신을 할 수 있을까?

컴퓨터에 **인터넷 프로토콜(IP)**를 부여해 이를 이용하여 통신한다. IP는 지정한 IP 주소에 패킷(Packet)이라는 통신 단위로 데이터 전달을 한다.

### 패킷 (packet)

pack + bucket ⇒ 소포로 비유할 수 있다.

데이터를 무사히 전송하기 위해 **출발지 IP, 도착지 IP 같은 정보**가 포함되어 있다.

- 패킷 단위로 전송을 하면 노드(서버 컴퓨터)들은 목적지 IP에 도착하기 위해 서로 데이터를 전달한다. 이렇게 복잡한 인터넷 망 사이에서 정확한 목적지로 패킷을 전송할 수 있다.
- 또한 서버도 데이터를 무사히 전송 받으면, 이에 대한 응답을 IP 패킷을 이용해 클라이언트에게 전달한다.

### IP 프로토콜의 한계

**1. 비연결성**

- 패킷을 받을 대상이 없거나, 서비스 불능 상태여도 패킷을 전송한다.
  클라이언트는 서버의 상태를 파악할 방법이 없으므로, 패킷을 그대로 전송한다.

**2. 비신뢰성**

- 중간에 패킷이 사라질 수 있다.
  중간에 있는 서버가 데이터를 전달하던 중 장애가 생겨 중간에 패킷을 소실하더라도 클라이언트는 이를 파악할 수 없다.
- 패킷의 순서를 보장할 수 없다.
  전달 데이터의 용량이 클 경우, 데이터를 패킷 단위로 나누어 전달하는데, 이 패킷들은 중간에 다른 노드들을 통해 전달될 수 있다. 이렇게 되면 클라이언트가 의도되지 않은 순서로 서버에 패킷이 도착할 수 있다.

---

#

## 네트워크 계층 구조

### OSI 7 계층과 TCP/IP 4 계층

TCP/IP 4 계층은 OSI 7 계층보다 먼저 개발되었으며 TCP/IP 프로토콜의 계층은 OSI 모델의 계층과 정확하게 일치하지는 않는다.

네트워크 프로토콜 계층은 다음과 같이 나눌 수 있다. IP 프로토콜 보다 더 높은 계층에 **TCP 프로토콜**이 존재하므로, 앞의 **IP 프로토콜의 한계를 보완**할 수 있다.

ex) 채팅 프로그램에서 메세지를 보낼 때 어떤 일이 일어나는가?

HTTP 메세지 생성 - **Socket 라이브러리**를 통해 전달 - **TCP 정보 생성/** 메세지 데이터 포함 - **IP 패킷 생성**, TCP 데이터 포함 - **TCP/IP 패킷**은 LAN과 같은 물리적 계층을 지나기 위해 **이더넷 프레임워크**에 포함되어 서버로 전송

- **네트워크 소켓(Socket)**

  프로그램이 네트워크에서 데이터를 송수신 할 수 있도록, "네트워크 환경에 연결할 수 있게 만들어진 연결부"가 네트워크 소켓이다.

- **TCP/IP 패킷**
  IP 패킷의 출발지 IP, 목적지 IP 뿐만 아니라, 이를 보완할 수 있는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함한다.

#

### TCP 특징

전송 제어 프로토콜(Transmission Control Protocol)

- **연결 지향 - TCP 3way handshake(가상 연결)**

  TCP는 장치들 사이에 논리적인 접속을 성립하기 위해 사용하는 **연결 지향형 프로토콜**이다.

  1. 클라이언트가 서버에 접속을 요청하는 **syn 패킷**을 보낸다.
  2. 서버가 syn 요청을 받고, 클라이언트에게 요청을 수락하는 **ack + syn이 설정된 패킷**을 발송한다.
  3. 클라가 서버에게 다시 **ack**을 보내면 이 이후로부터 **연결이 성립**되며 데이터를 전송한다.

  여기서 만약 서버가 꺼져 있다면, 클라이언트가 syn을 보내면 응답이 없으므로 데이터를 보내지 않는다. ⇒ **비연결성 보완**

- **데이터 전달 보증**
  TCP는 데이터 전송이 성공적으로 이루어지면 이에 대한 응답을 돌려준다. ⇒ 비연결성 보완
- **순서 보장**
  패킷이 순서대로 도착하지 않으면, TCP 세그먼트의 정보를 토대로 **다시 패킷에 정보를 요청**한다.
  ⇒ 비신뢰성 보완
- **신뢰할 수 있는 프로토콜**
  - UDP에 비해 상대적으로 신뢰할 수 있는 프로토콜이다. 왜 일까?

#

### UDP 특징

사용자 데이터그램 프로토콜(User Datagram Protocol)

- **기능이 거의 없다.**
  - IP 프로토콜에 PORT, 체크섬 필드 정보만 추가된 단순한 프로토콜
  - HTTP3은 이미 여러 기능이 구현된 TCP보다는 UDP를 사용하여 커스터마이징이 가능하다.
  - **체크섬(checksum)**: 중복 검사의 한 형태. 오류 정정을 통해 공간(전자 통신)이나 시간(기억 장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법
- **비 연결 지향 - TCP 3way handshake X**
- **데이터 전달 보증 X**
- **순서 보장 X**
- **단순하고 빠르다.**
  신뢰성은 낮지만, 3 way handshake를 사용하지 않기 때문에 TCP와 비교했을 때 빠른 속도를 보장
- **신뢰성보다는 연속성이 중요한 서비스에 자주 사용 (실시간 스트리밍 등)**

---

# HTTP

### HTTP의 역사

- 1991 - **HTTP/0.9**
  - GET 메서드만 지원
  - HTTP 헤더 X
- 1996 - **HTTP/1.0**
  - 메서드, 헤더 추가
- 1997 - **HTTP/1.1** - RFC2068
  - 현재 HTTP/1.1 주로 사용
  - 우리에게 가장 중요한 버전
  - TCP
- 1999 - RFC2616 (TCP)
- 2014 - RFC7230 ~ 7235 (TCP)
- 2015 - **HTTP/2**
  - 성능 개선
  - TCP
- 현재 - **HTTP/3 진행 중**
  - TCP 대신 UDP 사용, 성능 개선

#

### HTTP 특징

**클라이언트 서버 구조**

- 클라이언트가 서버에 요청을 보내면, 서버는 그에 대한 응답을 보내는 클라이언트 서버 구조로 되어 있다.

**무상태 프로토콜 (Stateless)**

- **서버가 클라이언트의 상태를 보존하지 않는다.**
- **서버의 확장성이 높다**(스케일 아웃)
  - 무상태는 응답 서버를 쉽게 바꿀 수 있다. 클라이언트가 요청할 때 이미 필요한 데이터를 담아서 보내므로 아무 서버나 호출한다. 한 서버에서 장애가 생겨도 다른 서버에서 응답을 전달하면 되기 때문에 다시 요청할 필요가 없다.
  - 이렇게 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하다.
  - 또한 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
- **클라이언트가 추가 데이터를 전송**해야 하는 단점이 있다.
  - 로그인이 필요없는 단순한 서비스 소개화면은 무상태로 설계할 수 있다.
  - 로그인이 필요한 서비스라면, 유저의 상태를 유지해야 하므로, 브라우저 쿠키, 서버 세션, 토큰 등을 이용해 상태를 유지해야 한다.

**비연결성(Connectionless)**

- TCP/IP의 경우 기본적으로 연결을 유지하지만, 서버의 자원이 계속 소모된다.
- HTTP는 기본이 **연결을 유지하지 않는 모델**이다. (HTTP 1.0 기준)
- HTTP는 실제로 요청을 주고 받을 때만 연결을 유지하고, 응답을 주고나면 TCP/IP 연결을 끊는다. ⇒ 최소한의 자원으로 서버 유지
- 일반적으로 초 단위 이하의 빠른 속도로 응답
- 트래픽이 많지 않고 빠른 응답을 제공할 수 있는 경우 효율적이다.
  - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다.

**[ 한계/ 극복 ]**

- TCP/IP 연결을 새로 맺어야 한다. - **3 way shake 시간 추가**
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JS, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드 된다.
- 해당 자원을 각각 보낼 때마다 연결끊고, 연결하고를 반복하는 것은 **비효율적**이다.

⇒ **HTTP 지속 연결(Persistent Connections)**로 문제 해결 , HTTP/2, HTTP/3에서 더 많이 최적화 되어 있다.

HTTP 지속 연결은 연결이 이루어지고, 각 자원을 요청하고, 모든 자원에 대한 응답이 돌아온 후 연결을 종료한다.

**HTTP 메세지**

**단순함, 확장 가능**
